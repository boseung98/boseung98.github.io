---
layout: post
title: 프로세스(Process)
subtitle: 운영체제 프로세스 개념 정리 
categories: Operating system
tags: [Operating system]
---

# 프로세스

### 프로그램?

- 프로그램이란? 실행가능한(executable) 파일
    - 실행파일, 운영체제가 프로세스를 초기구동하는데 사용되는 파일
    - 보조기억장치에 저장되어있는 정적인 상태에서
    - 운영체제가 실행가능한 파일을 읽어들여서 프로그램을 실행

### 프로세스?

- 실행파일이 메모리에 로딩되어 실행된 상태
- 주기억장치에 상주된 프로그램이 cpu에 의해서 처리되는 상태
- 실행을 위해 메모리에 올라온 동적인 상태
- PCB(process control block)의 존재로서 명시되는 것
- 프로세서가 할당되는 개체로서, 디스패치가 가능한 단위
- 비동기적 행위를 일으키는 주체
- cpu가 할당되는 실체
- 운영체제가 관리하는 최소의 단위
- 프로그램과 달리 메모리 주소를 갖는 능동적인 객체

### 프로그램 여러개 실행 → 다중 프로그래밍

- 여러 프로세스들이 동시에 메모리에 있을 수 있음
- 프로세스는 상호 독립적인 메모리 공간에서 실행
- 다중 인스턴스
    - 같은 프로그램이어도 실행될 때마다 독립적인 프로세스 생성
    - 각 프로세스는 독립된 메모리 공간을 가지고, 별개의 프로세스로 취급

### Loading

- 실행파일이 메모리에 올라가는 과정
- 로더(loader) : 메모리에 Load(적재) 해주는것
- Memory allocation(프로그램을 위한 메모리 공간 할당) → Linking(외부 라이브러리 참조) → Relocation(상대주소의 절대주소로의 변환) → Loading(실제 프로그램과 데이터를 메모리에 적재)
- 절대 로더(Absolute loader)
    - 항상 고정된 위치에만 로딩됨, 재배치 및 링킹이 없음
    - 다중 프로그래밍 x
- 재배치 로더(Relocation loadeR)
    - 주기억장치의 상태에 따라 목적 프로그램을 주기억장치 임의의 공간에 적재
- 동적 로더(Dynamic loader)
    - 필요한 부분만 주기억장치로 적재하고 나머지 부분은 보조기억장치에 저장

### 프로세스의 생명주기

- 프로세스는 생명 주기동안 여러 상태로 변하면서 실행됨
    
    ![생명주기](https://user-images.githubusercontent.com/95980754/229329706-195df8b1-9478-4a1e-a43d-7d249aa1152f.png)
    

### 보류상태

- 프로세스가 어떠한 이유로 실행이 미뤄지고, 메모리에서 쫒겨난 상태 == 저장장치에 놓임

### 프로세스 관리

- 프로세스는 생성부터 종료까지 커널(운영체제)에 의해 관리됨
- 프로세스 생성주기 관리
- 프로세스 메타데이터  관리
- 프로세스 통신, 동기화
- 컨텍스트 스위칭(context switching, 문맥교환)

### PCB(Process Control Block)

- 운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장하는 자료구조
- 프로세스마다 고유의 PCB가 생성

### PCB의 구조

- 운영체제는 PCB들을 PCB table 또는 Process table이라는 곳을 통해 관리
- 프로세스의 Context(프로세스의 상태, Program Counter, PID 등)

### 다중 프로그래밍의 원리

- 시분할(Time-slicing)
    - 프로세스들에게 번갈아가면서 CPU를 사용하게 하자
    - ‘어떤 순서’로 번갈아가면서 작업하게 할 것인가? → 스케쥴링 문제
    - 어떻게 번갈아 가게 하지? → Context Switching

### 문맥 교환(Context Switching)

- 한 프로세스에서 다른 프로세스로 CPU를 넘겨주는 과정
    - 실행 상태에서 나가는 프로세스 : PCB에 현재까지 작업내용을 저장
    - 실행상태로 들어오는 프로세스 : PCB 내용으로 CPU가 다시 세팅

### CPU 주소 공간(CPU address space)

- CPU Bus 크기에 의해 결정 == Word == CPU 아키텍쳐 크기

### 프로세스 주소 공간(여러 프로세스가 나눠 써야하는 메모리 공간)

- 프로세스가 실행 중에 접근할 수 있도록 허용한 주소의 최대 범위 → Segmantation
    - 할당된 공간에 대한 경계 레지스터와 한계 레지스터를 벗어나는지 감시
    - CPU의 관점
- 프로세스 관점에서는 가상 메모리 개념 적용 → 프로세스는 자신이 CPU 주소 공간 전체를 독점하는 것처럼 보임
    - 모든 프로세스는 자신만의 가상 주소 공간을 가짐
    - 32bit CPU는 논리적으로 4GB 메모리를 할당받은 것처럼 보임
- 프로세스 주소 공간은 2부분으로 나뉘어짐
    - 사용자 공간 User space : 코드, 데이터, 힙, 스택 영역
    - 커널 공간 Kernel Space
        - 프로세스가 시스템 호출을 통해 사용하는 커널 공간
        - 커널 코드, 커널 데이터, 커널 스택
        - 커널 공간은 모든 사용자 프로세스에 의해 공유

### 왜 가상 공간을 사용할까?

- 메모리에 대한 확장성
    - 물리적 메모리는 한정적이지만, 가상 메모리는 더 큰 공간으로 구성 가능
    - 초과한 메모리는 보조기억장치 등을 활용, 가상 공간은 저장장치의 구분 없이 하나의 가상 공간으로 활용 가능 → PageSwap 필요
- 모든 프로그램에 대한 동일한 메모리 공간 제공
    - 각 프로세스는 다른 프로세스를 신경 쓸 필요 없음
    - 각 프로세스간 메모리 격리 → 보호
    - RTOS(Real Time Operation System) 등은 가상 메모리를 사용하지 않고 직접 접근하기도 함

### 프로세스가 메모리에 올라갈 때

- 코드 영역(크기가 compiled time 결정됨)
    - 실행될 프로그램 코드가 적재되는 영역
        - 사용자가 작성한 모든 함수의 코드 및 호출한 라이브러리 함수들의 코드
- 데이터 영역(크기가 compiled time 결정됨)
    - 전역 변수 공간, 정적 데이터(Static) 공간
    - 프로세스 적재 시 할당, 종료시 소멸
- 힙 영역(크기가 runtime 시 결정됨)
    - 프로세스가 실행 도중 동적으로 사용할 수 있도록 할당된 공간
    - malloc() 등으로 할당 받는 공간은 힙 영역에서 할당
    - 힙 영역은 아래번지로 내려가면서 할당
- 스택 영역(크기가 runtime 시 결정됨)
    - 함수가 실행될 때, 사용될 데이터를 위해 할당된 공간
        - 매개변수들, 지역변수들, 함수 종료 후 돌아갈 주소등
        - 함수는 호출될 때, 스택 영역에서 위쪽으로 공간 할당
    
    ![적재](https://user-images.githubusercontent.com/95980754/229329774-987ae39e-6195-4cec-9294-a9b3b50264a7.png)
    

### 왜 이렇게 생겼을까?

- Code 영역이 구분된 이유
    - 프로그램 Code는 프로그램이 만들어지고나서는 바뀔 일이 전혀 없음 → Read-Only
    - 같은 프로세스가 여러 프로세스로서 실행된다면? → 코드 영역을 공유함으로서 메모리 사용양을 줄일 수 있음
- Data 영역이 구분된 이유
    - 전역 변수와 정적 변수가 저장되는 영역 → 변수니까 Read-Write
    - 전역 및 정적 변수 → 프로그램 구동 도중 항상 접근 가능해야 함 → 프로그램 실행과 관련없이 독립적인 공간 필요
- Heap 영역이 구분된 이유
    - 프로그램이 실행 도중에 필요할 때마다 할당 받는 공간 → 얼마나 필요할지 모름
    - Stack 영역도 마찬가지로 얼마나 사용될지 모름 → 동적 공간에서 유연하게 활용
- Stack 영역이 구분된 이유
    - 함수는 프로그램의 실행 단위
    - 스택 구조를 사용하면 함수의 호출 순서와 반환 대상 등의 관리가 편함

### 프로세스 생성

- 프로세스는 언제 생성되는가?
    - 시스템 부팅과정에서 필요한 프로세스 생성
    - 사용자 응용 프로그램이 시스템 호출로 새 프로세스 생성
- **중요한건 메모리에 올라왔다고 단순히 프로세스가 아님!**
    - PCB가 존재해서 OS가 제어 가능한 상태가 되어야 함 == CPU를 할당받아 실행 가능

### 프로세스 생성 과정

1. 생성하려는 실행파일의 경로를 OS에게 전달
2. OS는 메모리에 프로그램을 적재
    - Code 영역에 프로그램 코드 적재, Data 영역엔 전역 / 정적 변수들을 할당
    - 스택과 힙은 아무것도 없으므로 초기화만
3. PCB 공간을 부여 받고 필요한 정보를 채움
    - 프로세스 식별자를 할당 - 새로운 PID 번호를 부여
    - 프로세스 정보 기록
    - 프로세스 테이블에서 새 항목 할당
    - 새로 할당된 프로세스 테이블에 PCB 할당
4. PCB에 프로세스 상태를 ready 상태로 표시하고, 준비큐에 장착

### 복사에 의한 생성 fork()

- 기존에 있는 프로세스가 다른 프로세스를 생성
    - 프로세스를 복사하는 시스템 콜에 의해 프로세스 생성
        - 리눅스 : fork() 시스템 콜
- Unix 계열의 OS는 시스템이 부팅할 때, 0번 프로세스(init)만 자체 생성
    - 나머지 프로세스는 ‘복제’를 통해 생성
        - 자주 사용되는 프로세스에 매번 반복할 필요가 없음
        - 관리상 편해짐(프로세스 계층 구조)
        - Process 간 통신

### fork() 시스템 콜

- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
    - fork를 호출한 함수: 부모 프로세스, fork된 프로세스: 자식 프로세스
    - 부모 프로세스의 모든 환경, 메모리, PCB 등을 복사
    - 부모 프로세스와 독립된 주소 공간에 위치
    - **단, PCB에서 아래 내용은 달라짐**
        - PID는 다름! (다른 프로세스이니까)
        - PPID: 부모 PID로
        - CPID: 자식이 없으면 -1
        - 메모리 관련 정보: 독립된 주소 공간을 소유하므로

### fork() 실행 과정

```c
pid_t pid; // pid 변수 선언

pid = fork(); // 자식 프로세스 생성
if(pid > 0) {
/* 이곳에 부모 프로세스가 계속 실행할 코드 작성 */
}
else if(pid == 0) {
/* 이곳에 자식 프로세스가 실행할 코드 작성 */
}
else {
/* fork() 오류를 처리하는 코드 작성 */
}
```

- 자식은 부모의 Program Counter도 복사해서 fork() 다음의 if(pid == 0) 라인부터 실행됨
    - pid = fork() 이전 라인 실행하지 못함
- fork() 함수의 리턴값
    - 부모 프로세스에게는 자식 프로세스의 PID 리턴
    - 자식 프로세스에게는 0 리턴

### fork()의 장점과 단점

- 장점
    - 프로세스 생성 속도가 빠름
    - 추가 작업 없이 자원을 상속 할 수 있음
    - 시스템 관리를 효율적으로 할 수 있음(프로세스 계층 구조)
- 단점
    - 매번 모든 Context를 복사하는 것은 비효율적
    - 특히 맨 처음 만든 프로세스 외에는 다른 프로세스 실행 불가능
        - 계속 같은 프로세스만 복사되기 때문에
    - 그래서 Unix OS는 fork() 다음 exec()라는 시스템 콜을 호출

### 프로세스 오버레이(Process overlay) : exec()

- 기존의 프로세스를 새로운 프로세스로 전환해서 사용하는 함수
- 현재 실행 중인 프로세스의 주소 공간에 새로운 응용프로그램을 적재하고 실행
- 프로세스는 그대로 두고 내용만 바꾸는 시스템 호출
- 주의! 프로세스를 새로 생성하는게 아님
    - 프로세스 PID 변경 X
    - 프로세스의 메모리 공간(Code, Data, 힙, 스택)에 새로운 프로그램 적재
    - 보통 fork()를 통해 생성된 자식 프로세스가 exec() 실행
    - loader가 exec를 통해 호출됨

### exec() 실행 과정

- 메모리
    - Code 영역에 있는 기존의 내용을 지우고 새로운 내용으로 바꿔버림
    - Data 영역은 새로운 변수로 채워지고, 힙/스택 영역은 리셋
- PCB
    - PID, PPID, CPID, 메모리 관련은 유지
        - 새로운 프로세스로 전환되더라도 종료 후 부모 프로세스로 돌아올 수 있음
    - Program Counter 및 기타 register 파일 정보등 리셋

### wait() 시스템 콜

- 자식 프로세스가 끝나기를 기다렸다가, 자식 프로세스가 종료되면 이어서 실행을 계속하는 시스템 콜

### exit() 시스템 콜

- 작업의 종료를 알리는 시스템 콜
    - **종료를 명시적으로 알림**으로서 부모는 자식이 사용하던 자원을 빨리 회수
- 종료 코드
    - 부모 프로세스에게 상태나 종료의 이유를 알려주는 값
    - 보통 정상 코드는 0, 나머지는 1-255 범위 내에서 임의 사용
    - 이걸 부모가 확인해야 최종적으로 자식 프로세스가 종료됨

### exit() 시스템 콜을 통한 프로세스 종료 과정

1. 프로세스의 모든 자원 반환
    - 코드, 데이터, 스택, 힙 등의 모든 메모리 자원 반환
    - 열어놓은 파일이나 소캣 등 닫음
2. PCB에 프로세스 상태 Terminated로 변경, PCB에 종료 코드 저장
    - 아직 PCB가 프로세스 테이블에서 제거된 상태는 아님, 후술할 부모가 종료를 확인해야 함
3. 자식 프로세스들을 init 프로세스에게 입양
4. 부모 프로세스에게 SIGCHLD 신호 전송(일종의 종료 알림 신호)
    - 부모의 의무
        - SIGCHLD를 수신하고, wait() 호출로 자식 종료 코드 읽기 실행
        - 죽은 자식이 남긴 정보를 확인 후, 자식 프로세스의 PCB가 완전히 제거됨
    - 만약에 부모가 자식의 종료 신호를 제때 확인하지 못하면?
        - 자식은 좀비 프로세스가 됨!
        - PCB가 남아있으므로 ps 명령어 등으로 존재를 확인 할 수 있다.
            - 이미 메모리 정리는 다 됐으므로 점유하는 메모리 size = 0!
            - 좀비 프로세스는 단순히 PCB 정리가 안된것 뿐임!

### UNIX OS에서의 프로세스 생성(및 종료) 과정

- fork() → exec()의 구조
    - fork()를 통해 프로세스를 만들고, exec()를 통해 필요한 프로세스를 실행함
    - 이때 생성을 한 프로세스는 부모 프로세스, 생성된 프로세스는 자식 프로세스
    - 부모는 wait()을 통해 기다리고, 자식은 exit()를 통해 자신의 종료를 알림
- 모든 프로세스는 최초의 조상이 있다!
    - 1번 프로세스, init!

### 왜 이렇게 복잡하게 프로세스를 생성하는걸까?

- 프로세스 생성이 간소화됨
- 프로세스 관리가 쉬워짐
    - 부모를 통해 자식을 관리할 수 있음(프로세스 계층 구조)
        - abort() 호출: 부모가 신호를 보내서 자식을 죽이는 시스템 콜
- 프로세스간 통신 가능(IPC)
    - 프로세스는 독자적인 메모리 공간(가상 주소 공간)을 가진 것처럼 운영
    - **서로 간섭 불가, 통신 불가!**
    - 파일을 통해서 서로 의사소통 여기서 fork()가 사용!

### 모든 프로세스의 조상 init()

- 유닉스의 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 이룸

### 계층 구조

- 프로세스는 일반적으로 부모-자식 관계
    - #0번 프로세스는 시스템 부팅시 실행되는 최초의 프로세스, 조상 프로세스
- 자식 프로세스의 생성
    - 모든 프로세스는 프로세스(부모)에 의해 생성
    - 프로세스 생성은 시스템 호출을 통해서만 가능: fork()
- PID 0, 1, 2등의 몇몇 조상 프로세스는 시스템 콜이 아닌 OS 차원에서 수작업으로 생성됨!

### 왜 계층 ‘fork-exec’ 구조인가?

- 여러 작업을 처리하기에 용이
    
    ![동시처리](https://user-images.githubusercontent.com/95980754/229329806-0d493418-5593-4abd-b983-26043dec58c8.png)
    
- 프로세스의 재사용이 용이
    
    ![재사용](https://user-images.githubusercontent.com/95980754/229329815-93159bc2-8773-4b72-ae6f-053ef5314a22.png)
    
- 관리가 용이
    - 자원 회수 등이 쉬움

### 좀비 프로세스의 제거

- 좀비 프로세스가 메모리를 차지하지는 않는다 하지만, PCB의 낭비 발생!
    - 커널의 입장에서 봤을때, PCB를 유지하기 위한 얼마간의 자원소모
    - 무엇보다 커널이 유지할 수 있는 PCB 테이블의 크기에 제한이 있음
        - 많은 좀비 프로세스가 발생하면 시스템 성능에 영향
- 좀비 프로세스 제거
    - 부모 프로세스에게 SIGCHLD 신호를 보내기 → 부모 프로세스에서 wait() 호출하여 처리
    - 부모 프로세스를 강제 종료 → 좀비 프로세스의 고아(Orphan)화 → 좀비는 init() 프로세스의 자식이 되고 → init 프로세스가 wait()을 호출하여 좀비 프로세스 제거

### 고아 프로세스(Orphan Process)

- 부모가 먼저 종료한 자식 프로세스
- 부모 프로세스가 종료할 때 일반적으로
    - 커널(exit() 시스템 호출 코드)은 자식 프로세스가 있는지 확인
    - 자식이 있으면 자식 프로세스(고아)를 init 프로세스에게 입양 → PPID가 1로 변경

### 다른 프로세스 종료

- 백그라운드 프로세스(Background process)
    - 터미널에서 실행되었지만 터미널 사용자와 대화가 없는 채 실행되는 프로세스
    - 사용자의 입력을 필요로 하지 않는 프로세스
- 포그라운드 프로세스(Foreground process)
    - 실행되는 동안 사용자의 입력을 독점하는 프로세스
- CPU 집중 프로세스
    - 대부분의 시간을 CPU 작업을 하느라 시간을 보내는 프로세스
    - CPU 속도가 성능 좌우
- I/O 집중 프로세스
    - 입출력 작업을 하느라 대부분의 시간을 보내는 프로세스
    - 입출력 장치나 입출력 시스템의 속도가 성능 좌우
- 운영체제의 스케줄링 우선순위: I/O 집중 프로세스 > CPU 집중 프로세스

### 프로세스 조상

- 모든 프로세스의 조상 init
    - 그 위, 옆 프로세스는??
    
    ![조상프로세스](https://user-images.githubusercontent.com/95980754/229329827-3ff8352a-f4ba-4314-8b51-283b84fefb08.png)

- 0번 프로세스
    - swapper(UNIX): 부팅 담당 및 #1 init을 담당
    - idle(LINUX), system idle process(Windows)
        - 우선 순위가 가장 낮은 프로세스, 아무것도 안함
        - 실행 중인 프로세스가 1개도 없는 상태에 빠지지 않게 만든 프로세스
- 2번 프로세스
    - 커널 프로세스는 커널 공간에서만 실행하는 프로세스를 의미
    - 대부분 커널 스레드 형태로 구동 → kthreadd 모든 커널 프로세스(thread)의 조상