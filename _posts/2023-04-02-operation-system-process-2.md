---
layout: post
title: 프로세스(Process) 2
subtitle: 운영체제 프로세스 개념 정리 
categories: Operating-system
tags: [Operating-system]
---

### 프로세스 생성

- 프로세스는 언제 생성되는가?
    - 시스템 부팅과정에서 필요한 프로세스 생성
    - 사용자 응용 프로그램이 시스템 호출로 새 프로세스 생성
- **중요한건 메모리에 올라왔다고 단순히 프로세스가 아님!**
    - PCB가 존재해서 OS가 제어 가능한 상태가 되어야 함 == CPU를 할당받아 실행 가능

### 프로세스 생성 과정

1. 생성하려는 실행파일의 경로를 OS에게 전달
2. OS는 메모리에 프로그램을 적재
    - Code 영역에 프로그램 코드 적재, Data 영역엔 전역 / 정적 변수들을 할당
    - 스택과 힙은 아무것도 없으므로 초기화만
3. PCB 공간을 부여 받고 필요한 정보를 채움
    - 프로세스 식별자를 할당 - 새로운 PID 번호를 부여
    - 프로세스 정보 기록
    - 프로세스 테이블에서 새 항목 할당
    - 새로 할당된 프로세스 테이블에 PCB 할당
4. PCB에 프로세스 상태를 ready 상태로 표시하고, 준비큐에 장착

### 복사에 의한 생성 fork()

- 기존에 있는 프로세스가 다른 프로세스를 생성
    - 프로세스를 복사하는 시스템 콜에 의해 프로세스 생성
        - 리눅스 : fork() 시스템 콜
- Unix 계열의 OS는 시스템이 부팅할 때, 0번 프로세스(init)만 자체 생성
    - 나머지 프로세스는 ‘복제’를 통해 생성
        - 자주 사용되는 프로세스에 매번 반복할 필요가 없음
        - 관리상 편해짐(프로세스 계층 구조)
        - Process 간 통신

### fork() 시스템 콜

- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
    - fork를 호출한 함수: 부모 프로세스, fork된 프로세스: 자식 프로세스
    - 부모 프로세스의 모든 환경, 메모리, PCB 등을 복사
    - 부모 프로세스와 독립된 주소 공간에 위치
    - **단, PCB에서 아래 내용은 달라짐**
        - PID는 다름! (다른 프로세스이니까)
        - PPID: 부모 PID로
        - CPID: 자식이 없으면 -1
        - 메모리 관련 정보: 독립된 주소 공간을 소유하므로

### fork() 실행 과정

```c
pid_t pid; // pid 변수 선언

pid = fork(); // 자식 프로세스 생성
if(pid > 0) {
/* 이곳에 부모 프로세스가 계속 실행할 코드 작성 */
}
else if(pid == 0) {
/* 이곳에 자식 프로세스가 실행할 코드 작성 */
}
else {
/* fork() 오류를 처리하는 코드 작성 */
}
```

- 자식은 부모의 Program Counter도 복사해서 fork() 다음의 if(pid == 0) 라인부터 실행됨
    - pid = fork() 이전 라인 실행하지 못함
- fork() 함수의 리턴값
    - 부모 프로세스에게는 자식 프로세스의 PID 리턴
    - 자식 프로세스에게는 0 리턴

### fork()의 장점과 단점

- 장점
    - 프로세스 생성 속도가 빠름
    - 추가 작업 없이 자원을 상속 할 수 있음
    - 시스템 관리를 효율적으로 할 수 있음(프로세스 계층 구조)
- 단점
    - 매번 모든 Context를 복사하는 것은 비효율적
    - 특히 맨 처음 만든 프로세스 외에는 다른 프로세스 실행 불가능
        - 계속 같은 프로세스만 복사되기 때문에
    - 그래서 Unix OS는 fork() 다음 exec()라는 시스템 콜을 호출

### 프로세스 오버레이(Process overlay) : exec()

- 기존의 프로세스를 새로운 프로세스로 전환해서 사용하는 함수
- 현재 실행 중인 프로세스의 주소 공간에 새로운 응용프로그램을 적재하고 실행
- 프로세스는 그대로 두고 내용만 바꾸는 시스템 호출
- 주의! 프로세스를 새로 생성하는게 아님
    - 프로세스 PID 변경 X
    - 프로세스의 메모리 공간(Code, Data, 힙, 스택)에 새로운 프로그램 적재
    - 보통 fork()를 통해 생성된 자식 프로세스가 exec() 실행
    - loader가 exec를 통해 호출됨

### exec() 실행 과정

- 메모리
    - Code 영역에 있는 기존의 내용을 지우고 새로운 내용으로 바꿔버림
    - Data 영역은 새로운 변수로 채워지고, 힙/스택 영역은 리셋
- PCB
    - PID, PPID, CPID, 메모리 관련은 유지
        - 새로운 프로세스로 전환되더라도 종료 후 부모 프로세스로 돌아올 수 있음
    - Program Counter 및 기타 register 파일 정보등 리셋

### wait() 시스템 콜

- 자식 프로세스가 끝나기를 기다렸다가, 자식 프로세스가 종료되면 이어서 실행을 계속하는 시스템 콜

### exit() 시스템 콜

- 작업의 종료를 알리는 시스템 콜
    - **종료를 명시적으로 알림**으로서 부모는 자식이 사용하던 자원을 빨리 회수
- 종료 코드
    - 부모 프로세스에게 상태나 종료의 이유를 알려주는 값
    - 보통 정상 코드는 0, 나머지는 1-255 범위 내에서 임의 사용
    - 이걸 부모가 확인해야 최종적으로 자식 프로세스가 종료됨

### exit() 시스템 콜을 통한 프로세스 종료 과정

1. 프로세스의 모든 자원 반환
    - 코드, 데이터, 스택, 힙 등의 모든 메모리 자원 반환
    - 열어놓은 파일이나 소캣 등 닫음
2. PCB에 프로세스 상태 Terminated로 변경, PCB에 종료 코드 저장
    - 아직 PCB가 프로세스 테이블에서 제거된 상태는 아님, 후술할 부모가 종료를 확인해야 함
3. 자식 프로세스들을 init 프로세스에게 입양
4. 부모 프로세스에게 SIGCHLD 신호 전송(일종의 종료 알림 신호)
    - 부모의 의무
        - SIGCHLD를 수신하고, wait() 호출로 자식 종료 코드 읽기 실행
        - 죽은 자식이 남긴 정보를 확인 후, 자식 프로세스의 PCB가 완전히 제거됨
    - 만약에 부모가 자식의 종료 신호를 제때 확인하지 못하면?
        - 자식은 좀비 프로세스가 됨!
        - PCB가 남아있으므로 ps 명령어 등으로 존재를 확인 할 수 있다.
            - 이미 메모리 정리는 다 됐으므로 점유하는 메모리 size = 0!
            - 좀비 프로세스는 단순히 PCB 정리가 안된것 뿐임!

### UNIX OS에서의 프로세스 생성(및 종료) 과정

- fork() → exec()의 구조
    - fork()를 통해 프로세스를 만들고, exec()를 통해 필요한 프로세스를 실행함
    - 이때 생성을 한 프로세스는 부모 프로세스, 생성된 프로세스는 자식 프로세스
    - 부모는 wait()을 통해 기다리고, 자식은 exit()를 통해 자신의 종료를 알림
- 모든 프로세스는 최초의 조상이 있다!
    - 1번 프로세스, init!

### 왜 이렇게 복잡하게 프로세스를 생성하는걸까?

- 프로세스 생성이 간소화됨
- 프로세스 관리가 쉬워짐
    - 부모를 통해 자식을 관리할 수 있음(프로세스 계층 구조)
        - abort() 호출: 부모가 신호를 보내서 자식을 죽이는 시스템 콜
- 프로세스간 통신 가능(IPC)
    - 프로세스는 독자적인 메모리 공간(가상 주소 공간)을 가진 것처럼 운영
    - **서로 간섭 불가, 통신 불가!**
    - 파일을 통해서 서로 의사소통 여기서 fork()가 사용!

### 모든 프로세스의 조상 init()

- 유닉스의 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 이룸

### 계층 구조

- 프로세스는 일반적으로 부모-자식 관계
    - #0번 프로세스는 시스템 부팅시 실행되는 최초의 프로세스, 조상 프로세스
- 자식 프로세스의 생성
    - 모든 프로세스는 프로세스(부모)에 의해 생성
    - 프로세스 생성은 시스템 호출을 통해서만 가능: fork()
- PID 0, 1, 2등의 몇몇 조상 프로세스는 시스템 콜이 아닌 OS 차원에서 수작업으로 생성됨!

### 왜 계층 ‘fork-exec’ 구조인가?

- 여러 작업을 처리하기에 용이
    
    ![동시처리](https://user-images.githubusercontent.com/95980754/229329806-0d493418-5593-4abd-b983-26043dec58c8.png)
    
- 프로세스의 재사용이 용이
    
    ![재사용](https://user-images.githubusercontent.com/95980754/229329815-93159bc2-8773-4b72-ae6f-053ef5314a22.png)
    
- 관리가 용이
    - 자원 회수 등이 쉬움

### 좀비 프로세스의 제거

- 좀비 프로세스가 메모리를 차지하지는 않는다 하지만, PCB의 낭비 발생!
    - 커널의 입장에서 봤을때, PCB를 유지하기 위한 얼마간의 자원소모
    - 무엇보다 커널이 유지할 수 있는 PCB 테이블의 크기에 제한이 있음
        - 많은 좀비 프로세스가 발생하면 시스템 성능에 영향
- 좀비 프로세스 제거
    - 부모 프로세스에게 SIGCHLD 신호를 보내기 → 부모 프로세스에서 wait() 호출하여 처리
    - 부모 프로세스를 강제 종료 → 좀비 프로세스의 고아(Orphan)화 → 좀비는 init() 프로세스의 자식이 되고 → init 프로세스가 wait()을 호출하여 좀비 프로세스 제거

### 고아 프로세스(Orphan Process)

- 부모가 먼저 종료한 자식 프로세스
- 부모 프로세스가 종료할 때 일반적으로
    - 커널(exit() 시스템 호출 코드)은 자식 프로세스가 있는지 확인
    - 자식이 있으면 자식 프로세스(고아)를 init 프로세스에게 입양 → PPID가 1로 변경

### 다른 프로세스 종료

- 백그라운드 프로세스(Background process)
    - 터미널에서 실행되었지만 터미널 사용자와 대화가 없는 채 실행되는 프로세스
    - 사용자의 입력을 필요로 하지 않는 프로세스
- 포그라운드 프로세스(Foreground process)
    - 실행되는 동안 사용자의 입력을 독점하는 프로세스
- CPU 집중 프로세스
    - 대부분의 시간을 CPU 작업을 하느라 시간을 보내는 프로세스
    - CPU 속도가 성능 좌우
- I/O 집중 프로세스
    - 입출력 작업을 하느라 대부분의 시간을 보내는 프로세스
    - 입출력 장치나 입출력 시스템의 속도가 성능 좌우
- 운영체제의 스케줄링 우선순위: I/O 집중 프로세스 > CPU 집중 프로세스

### 프로세스 조상

- 모든 프로세스의 조상 init
    - 그 위, 옆 프로세스는??
    
    ![조상프로세스](https://user-images.githubusercontent.com/95980754/229329827-3ff8352a-f4ba-4314-8b51-283b84fefb08.png)

- 0번 프로세스
    - swapper(UNIX): 부팅 담당 및 #1 init을 담당
    - idle(LINUX), system idle process(Windows)
        - 우선 순위가 가장 낮은 프로세스, 아무것도 안함
        - 실행 중인 프로세스가 1개도 없는 상태에 빠지지 않게 만든 프로세스
- 2번 프로세스
    - 커널 프로세스는 커널 공간에서만 실행하는 프로세스를 의미
    - 대부분 커널 스레드 형태로 구동 → kthreadd 모든 커널 프로세스(thread)의 조상