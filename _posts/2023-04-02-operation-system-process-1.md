---
layout: post
title: 프로세스(Process) 1
subtitle: 운영체제 프로세스 개념 정리 
categories: Operating-system
tags: [Operating-system]
---

### 프로그램?

- 프로그램이란? 실행가능한(executable) 파일
    - 실행파일, 운영체제가 프로세스를 초기구동하는데 사용되는 파일
    - 보조기억장치에 저장되어있는 정적인 상태에서
    - 운영체제가 실행가능한 파일을 읽어들여서 프로그램을 실행

### 프로세스?

- 실행파일이 메모리에 로딩되어 실행된 상태
- 주기억장치에 상주된 프로그램이 cpu에 의해서 처리되는 상태
- 실행을 위해 메모리에 올라온 동적인 상태
- PCB(process control block)의 존재로서 명시되는 것
- 프로세서가 할당되는 개체로서, 디스패치가 가능한 단위
- 비동기적 행위를 일으키는 주체
- cpu가 할당되는 실체
- 운영체제가 관리하는 최소의 단위
- 프로그램과 달리 메모리 주소를 갖는 능동적인 객체

### 프로그램 여러개 실행 → 다중 프로그래밍

- 여러 프로세스들이 동시에 메모리에 있을 수 있음
- 프로세스는 상호 독립적인 메모리 공간에서 실행
- 다중 인스턴스
    - 같은 프로그램이어도 실행될 때마다 독립적인 프로세스 생성
    - 각 프로세스는 독립된 메모리 공간을 가지고, 별개의 프로세스로 취급

### Loading

- 실행파일이 메모리에 올라가는 과정
- 로더(loader) : 메모리에 Load(적재) 해주는것
- Memory allocation(프로그램을 위한 메모리 공간 할당) → Linking(외부 라이브러리 참조) → Relocation(상대주소의 절대주소로의 변환) → Loading(실제 프로그램과 데이터를 메모리에 적재)
- 절대 로더(Absolute loader)
    - 항상 고정된 위치에만 로딩됨, 재배치 및 링킹이 없음
    - 다중 프로그래밍 x
- 재배치 로더(Relocation loadeR)
    - 주기억장치의 상태에 따라 목적 프로그램을 주기억장치 임의의 공간에 적재
- 동적 로더(Dynamic loader)
    - 필요한 부분만 주기억장치로 적재하고 나머지 부분은 보조기억장치에 저장

### 프로세스의 생명주기

- 프로세스는 생명 주기동안 여러 상태로 변하면서 실행됨
    
    ![생명주기](https://user-images.githubusercontent.com/95980754/229329706-195df8b1-9478-4a1e-a43d-7d249aa1152f.png)
    

### 보류상태

- 프로세스가 어떠한 이유로 실행이 미뤄지고, 메모리에서 쫒겨난 상태 == 저장장치에 놓임

### 프로세스 관리

- 프로세스는 생성부터 종료까지 커널(운영체제)에 의해 관리됨
- 프로세스 생성주기 관리
- 프로세스 메타데이터  관리
- 프로세스 통신, 동기화
- 컨텍스트 스위칭(context switching, 문맥교환)

### PCB(Process Control Block)

- 운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장하는 자료구조
- 프로세스마다 고유의 PCB가 생성

### PCB의 구조

- 운영체제는 PCB들을 PCB table 또는 Process table이라는 곳을 통해 관리
- 프로세스의 Context(프로세스의 상태, Program Counter, PID 등)

### 다중 프로그래밍의 원리

- 시분할(Time-slicing)
    - 프로세스들에게 번갈아가면서 CPU를 사용하게 하자
    - ‘어떤 순서’로 번갈아가면서 작업하게 할 것인가? → 스케쥴링 문제
    - 어떻게 번갈아 가게 하지? → Context Switching

### 문맥 교환(Context Switching)

- 한 프로세스에서 다른 프로세스로 CPU를 넘겨주는 과정
    - 실행 상태에서 나가는 프로세스 : PCB에 현재까지 작업내용을 저장
    - 실행상태로 들어오는 프로세스 : PCB 내용으로 CPU가 다시 세팅

### CPU 주소 공간(CPU address space)

- CPU Bus 크기에 의해 결정 == Word == CPU 아키텍쳐 크기

### 프로세스 주소 공간(여러 프로세스가 나눠 써야하는 메모리 공간)

- 프로세스가 실행 중에 접근할 수 있도록 허용한 주소의 최대 범위 → Segmantation
    - 할당된 공간에 대한 경계 레지스터와 한계 레지스터를 벗어나는지 감시
    - CPU의 관점
- 프로세스 관점에서는 가상 메모리 개념 적용 → 프로세스는 자신이 CPU 주소 공간 전체를 독점하는 것처럼 보임
    - 모든 프로세스는 자신만의 가상 주소 공간을 가짐
    - 32bit CPU는 논리적으로 4GB 메모리를 할당받은 것처럼 보임
- 프로세스 주소 공간은 2부분으로 나뉘어짐
    - 사용자 공간 User space : 코드, 데이터, 힙, 스택 영역
    - 커널 공간 Kernel Space
        - 프로세스가 시스템 호출을 통해 사용하는 커널 공간
        - 커널 코드, 커널 데이터, 커널 스택
        - 커널 공간은 모든 사용자 프로세스에 의해 공유

### 왜 가상 공간을 사용할까?

- 메모리에 대한 확장성
    - 물리적 메모리는 한정적이지만, 가상 메모리는 더 큰 공간으로 구성 가능
    - 초과한 메모리는 보조기억장치 등을 활용, 가상 공간은 저장장치의 구분 없이 하나의 가상 공간으로 활용 가능 → PageSwap 필요
- 모든 프로그램에 대한 동일한 메모리 공간 제공
    - 각 프로세스는 다른 프로세스를 신경 쓸 필요 없음
    - 각 프로세스간 메모리 격리 → 보호
    - RTOS(Real Time Operation System) 등은 가상 메모리를 사용하지 않고 직접 접근하기도 함

### 프로세스가 메모리에 올라갈 때

- 코드 영역(크기가 compiled time 결정됨)
    - 실행될 프로그램 코드가 적재되는 영역
        - 사용자가 작성한 모든 함수의 코드 및 호출한 라이브러리 함수들의 코드
- 데이터 영역(크기가 compiled time 결정됨)
    - 전역 변수 공간, 정적 데이터(Static) 공간
    - 프로세스 적재 시 할당, 종료시 소멸
- 힙 영역(크기가 runtime 시 결정됨)
    - 프로세스가 실행 도중 동적으로 사용할 수 있도록 할당된 공간
    - malloc() 등으로 할당 받는 공간은 힙 영역에서 할당
    - 힙 영역은 아래번지로 내려가면서 할당
- 스택 영역(크기가 runtime 시 결정됨)
    - 함수가 실행될 때, 사용될 데이터를 위해 할당된 공간
        - 매개변수들, 지역변수들, 함수 종료 후 돌아갈 주소등
        - 함수는 호출될 때, 스택 영역에서 위쪽으로 공간 할당
    
    ![적재](https://user-images.githubusercontent.com/95980754/229329774-987ae39e-6195-4cec-9294-a9b3b50264a7.png)
    

### 왜 이렇게 생겼을까?

- Code 영역이 구분된 이유
    - 프로그램 Code는 프로그램이 만들어지고나서는 바뀔 일이 전혀 없음 → Read-Only
    - 같은 프로세스가 여러 프로세스로서 실행된다면? → 코드 영역을 공유함으로서 메모리 사용양을 줄일 수 있음
- Data 영역이 구분된 이유
    - 전역 변수와 정적 변수가 저장되는 영역 → 변수니까 Read-Write
    - 전역 및 정적 변수 → 프로그램 구동 도중 항상 접근 가능해야 함 → 프로그램 실행과 관련없이 독립적인 공간 필요
- Heap 영역이 구분된 이유
    - 프로그램이 실행 도중에 필요할 때마다 할당 받는 공간 → 얼마나 필요할지 모름
    - Stack 영역도 마찬가지로 얼마나 사용될지 모름 → 동적 공간에서 유연하게 활용
- Stack 영역이 구분된 이유
    - 함수는 프로그램의 실행 단위
    - 스택 구조를 사용하면 함수의 호출 순서와 반환 대상 등의 관리가 편함

